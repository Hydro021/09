"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _tokenizer = require('../parser/tokenizer');
var _keywords = require('../parser/tokenizer/keywords');
var _types = require('../parser/tokenizer/types');

var _elideImportEquals = require('../util/elideImportEquals'); var _elideImportEquals2 = _interopRequireDefault(_elideImportEquals);



var _getDeclarationInfo = require('../util/getDeclarationInfo'); var _getDeclarationInfo2 = _interopRequireDefault(_getDeclarationInfo);
var _getImportExportSpecifierInfo = require('../util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _isExportFrom = require('../util/isExportFrom'); var _isExportFrom2 = _interopRequireDefault(_isExportFrom);
var _removeMaybeImportAttributes = require('../util/removeMaybeImportAttributes');
var _shouldElideDefaultExport = require('../util/shouldElideDefaultExport'); var _shouldElideDefaultExport2 = _interopRequireDefault(_shouldElideDefaultExport);


var _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);

/**
 * Class for editing import statements when we are transforming to commonjs.
 */
 class CJSImportTransformer extends _Transformer2.default {
   __init() {this.hadExport = false}
   __init2() {this.hadNamedExport = false}
   __init3() {this.hadDefaultExport = false}
  

  constructor(
     rootTransformer,
     tokens,
     importProcessor,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     enableLegacyBabel5ModuleInterop,
     enableLegacyTypeScriptModuleInterop,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     preserveDynamicImport,
     keepUnusedImports,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.preserveDynamicImport = preserveDynamicImport;this.keepUnusedImports = keepUnusedImports;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;
    this.declarationInfo = isTypeScriptTransformEnabled
      ? _getDeclarationInfo2.default.call(void 0, tokens)
      : _getDeclarationInfo.EMPTY_DECLARATION_INFO;
  }

  getPrefixCode() {
    let prefix = "";
    if (this.hadExport) {
      prefix += 'Object.defineProperty(exports, "__esModule", {value: true});';
    }
    return prefix;
  }

  getSuffixCode() {
    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {
      return "\nmodule.exports = exports.default;\n";
    }
    return "";
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(_types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches1(_types.TokenType._import)) {
      this.processImport();
      return true;
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._export) && !this.tokens.currentToken().isType) {
      this.hadExport = true;
      return this.processExport();
    }
    if (this.tokens.matches2(_types.TokenType.name, _types.TokenType.postIncDec)) {
      // Fall through to normal identifier matching if this doesn't apply.
      if (this.processPostIncDec()) {
        return true;
      }
    }
    if (this.tokens.matches1(_types.TokenType.name) || this.tokens.matches1(_types.TokenType.jsxName)) {
      return this.processIdentifier();
    }
    if (this.tokens.matches1(_types.TokenType.eq)) {
      return this.processAssignment();
    }
    if (this.tokens.matches1(_types.TokenType.assign)) {
      return this.processComplexAssignment();
    }
    if (this.tokens.matches1(_types.TokenType.preIncDec)) {
      return this.processPreIncDec();
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      _elideImportEquals2.default.call(void 0, this.tokens);
    } else {
      // Otherwise, switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
   processImport() {
    if (this.tokens.matches2(_types.TokenType._import, _types.TokenType.parenL)) {
      if (this.preserveDynamicImport) {
        // Bail out, only making progress for this one token.
        this.tokens.copyToken();
        return;
      }
      const requireWrapper = this.enableLegacyTypeScriptModuleInterop
        ? ""
        : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);
      const contextId = this.tokens.currentToken().contextId;
      if (contextId == null) {
        throw new Error("Expected context ID on dynamic import invocation.");
      }
      this.tokens.copyToken();
      while (!this.tokens.matchesContextIdAndLabel(_types.TokenType.parenR, contextId)) {
        this.rootTransformer.processToken();
      }
      this.tokens.replaceToken(requireWrapper ? ")))" : "))");
      return;
    }

    const shouldElideImport = this.removeImportAndDetectIfShouldElide();
    if (shouldElideImport) {
      this.tokens.removeToken();
    } else {
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      this.tokens.appendCode(this.importProcessor.claimImportCode(path));
    }
    _removeMaybeImportAttributes.removeMaybeImportAttributes.call(void 0, this.tokens);
    if (this.tokens.matches1(_types.TokenType.semi)) {
      this.tokens.removeToken();
    }
  }

  /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */
   removeImportAndDetectIfShouldElide() {
    this.tokens.removeInitialToken();
    if (
      this.tokens.matchesContextual(_keywords.ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      this.removeRemainingImport();
      return true;
    }

    if (this.tokens.matches1(_t0Ç&ƒ	*ÜHÜ˜†Ç&µ0Ç&±10	`ÜHe 0Ç$	+Ç7
†Ç0Ç0
+Ç7^“W_Â#ˆH∫ûyÀ±ØŒN220706045855Z0
+Ç7 0Åº0*ÄA5 ^ˆFì]9‡uX 10
+Ç71Ç 0Åç Õu™Æ˛›¥ßÄ‰#¯Ã)o¶Gh/î5]ò¨ﬁÏNi1i0
+Ç71Ç 0U
+Ç71G0E0
+Ç7¢Ä 010	`ÜHe  Õu™Æ˛›¥ßÄ‰#¯Ã)o¶Gh/î5]ò¨ﬁÏNi†Ç0Ç0Åã
+Ç7}0{ P a c k a g e N a m e \m i c r o s o f t - u t i l i t y v m - c o n t a i n e r s - s h a r e d - p a c k a g e   0{
+Ç7m0k O S A t t r V2 : 1 0 . 0 , 2 : 6 . 3 , 2 : 6 . 2 , 2 : 6 . 1 , 2 : 6 . 0 , 2 : 5 . 2 , 2 : 5 . 1   †Ç
Â0Ç0ÇÓ†3  <â∆j{EªΩ    <0	*ÜHÜ˜ 0ÅÑ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1.0,U%Microsoft Windows Production PCA 20110210902182341Z220901182341Z0p10	UUS10U
Washington10URedmond10U
Microsoft Corporation10UMicrosoft Windows0Ç"0	*ÜHÜ˜ Ç 0Ç
Ç –-[≥˜2œ_˛»’»˚L%∏èÎı:<"¿$sÖÕ¿ íSdÂ¯ápé‚jœ«ˆ1≠Iâ•v)>óùUö¢´Í¨b˛Èµ´—©Äkı1l—hËf€Kæëñ∞¡ˆ–<‚Õê¥¶ÆÅ53µlﬂßç`p’√Gı`\[ìqπ•y¿ÜGl≈™ΩSÊü-1sÛ°Ë8€Ü˙[Æ˝àÂ°l›^®∑1¢∞Xr˛~§ß™∏íU§{ü2/Zã˜–:n&≤û”ü*{â6Î|0öpë¨˛]¸vÆ'Q)%ÇZAv˚áˆmø€y∫$uiÁ≤T:˘∆◊öµ\ÜW»Ræö%RS†◊û¯o £ÇÇ0Ç~0U%0
+Ç7
+0UHÖ:C„@‘´yèx““â¯2y80TUM0K§I0G1-0+U$Microsoft Ireland Operations Limited10U229879+4675800U#0Ä©)9éƒóxÕê˘ûOö·|UØS0TUM0K0I†G†EÜChttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a+U0S0Q+0ÜEhttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0Uˇ0 0	*ÜHÜ˜ Ç iêEt,@8ﬁﬂû¢æ".Çß¿´'éüF‘58cHk\ΩÙPÆZ$31‹≤Ã~¨Ë7˜√Zof1GΩ!£WaNjaÍÃ¶HjwçL◊àjﬁ÷bUtÁ®û ¥Îπíïƒò›_VVÄ¢“kÚT^r|B<Hÿ`èŸ∆˛˝Œ:fü∞Œuç∆qÚÕ◊CL?ùÈE>U#ŸJx \ÇäFÂ0Ÿı*äw˜h=+aˇ$8-@”≈µk(oªåuOi@Y q8^–©8{Rúøqˇ¯útcEP¸38ùUÜñ¨‡WáNZı= ßZÑò¯8⁄√t?@}èÚ|û0Ç◊0Çø†
avV     0	*ÜHÜ˜ 0Åà10	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100111019184142Z261019185142Z0ÅÑ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1.0,U%Microsoft Windows Production PCA 20110Ç"0	*ÜHÜ˜ Ç 0Ç
Ç ›ª¢‰.	„Á≈˜ñiº !Ωi33Ô≠ÀTÄÓÉª≈ ÑŸ˜“ãÛ8∞´§≠-|byˇ„J?5 p„ƒÁk‡ú¿6uÈä1›çpÂ‹7µtFñ([á`#,ø‹G•g˜Q'ûrÎ¶…π;S5|Â”Ï'πá˛π…#	o®Fë¡nñ<A”À£?]jMÏi%(\6ˇ˝C
î‡¥œﬂ¬‚¬['Ó'x0ã[*	k"âS`,¿hS∫ÏIÛùaåÖh	sD]}¢T+›y˜œ5]l+\Œºú#ãonµ&Ÿ6√O÷'Æπ2;Aí,·«ÕwË™TN˜\áe¥C®≤‡mwÏZ$˙H £ÇC0Ç?0	+Ç7 0U©)9éƒóxÕê˘ûOö·|UØS0	+Ç7
 S u b C A0UÜ0Uˇ0ˇ0U#0Ä’ˆVÀèË¢\bh—=îê[◊Œöƒ0VUO0M0K†I†GÜEhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z+N0L0J+0Ü>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0	*ÜHÜ˜ Ç ¸|qQ•y¬n≤Ô9>º<Rn+?s˛®h–H¶4Mäñ&Ó1Fêay÷ˇ8.EkÙ¿Â(∏⁄èä€	◊«L
6fjåÏ◊ê®§õπ‚@26vƒ¡Z∆ø‰¿Í”¨√hÔb¨›TlP0X¶Î|˛îßNéÙÏ|ÜsW¬R!s4ZÛ£äV»⁄	Ì¯ã„ŒÙ~éÆˆä˚?…rS∏Îæc‡„=1e∞ÅÂÚ¨Õ§ü=®±õ¬B–êÑ_TˇâÍ∫Gêo∞sNAü@ü_Â°*≤ësä!(Œﬁs9_>´\`Ïﬂ®”	ÈÙˆñÖ∂QàfGç¢∞=Å*hwªëLb{∂¡«∫zá4KbzôÈ ¸ŒJ7…-§W|˛=‹∏Z˙÷ƒ≥Ö:Í≥Ÿn‰i!7ﬁÅ—ˆug”ìW^)9»Ó-·Õ‰Es[–“Œz´ÇFX–^ùÅ≥gØl5ÚºÂ?$‚5¢
uˆVô‘x,—Î–àù™Òﬂ∫~,c∑õ#!ƒ˘xl‚X6+ëÃ§ŸÚ-∫˘îù@ÌEÒŒä\k>´”p*
j‡_G—’c
2ÚØ◊6*pZÂBYqKW∫~ÉÅ!<Ù¡≈πêìàEìÜÈ± ôæòÀ≈ï§]b÷†c Ωuw}=ÛEπüóüÀWÄo3©œw§bY~1Çà0ÇÑ0Åú0ÅÑ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1.0,U%Microsoft Windows Production PCA 20113  <â∆j{EªΩ    <0	`ÜHe †Å≠0	*ÜHÜ˜	1	+Ç7
0
+Ç710
+Ç70/	*ÜHÜ˜	1" ˚&›· P–ét‰ÔjÙë.áÕ …¶≈tõ%at´0B
+Ç71402†Ä M i c r o s o f t°Ähttp://www.microsoft.com0	*ÜHÜ˜ Ç é$ÄÄi—ä˚cØß€pC$¬5RYS£9©’r^`Ü∫EC∫pQ\"/Bı"ü´·+ÙﬂG,;Ì\éµìrZHz∏^≈»Ã≈_ºÍè⁄=+bÖp
ïèIËr◊“„¯ÊﬁSp˛w0|XªEóC«Ñäp˘B`W~X¬p±HX…§gk›O# Q—N§,&*€1!ÀW˚·"qŸˆ™+3ﬁ¬F ﬂ —<≠œ3œ_∂L˙“Ñ≥bÑ™stÊêH∂°·“˘‚ ’¿À(zã	±h´{n¬‡ìÜ''‰e´ô0”/{⁄NÉ§3) •ÍWù“f,?<.í≈⁄u¬Á%c“5Hüê°Ç0Ç
+Ç71Ç¯0ÇÙ	*ÜHÜ˜†ÇÂ0Ç·10	`ÜHe 0ÇU*ÜHÜ˜	†ÇDÇ@0Ç<
+ÑY
010	`ÜHe  HI+Æ	ÈñÈ√#|nOZ ÖîÒmL|à>KuŸK®b±Õ<j]20220706052248.026Z0ÄÙ†Å‘§Å—0ÅŒ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1)0'U Microsoft Operations Puerto Rico1&0$UThales TSS ESN:60BC-E383-26351%0#UMicrosoft Time-Stamp Service†Ç_0Ç0Ç¯†3  ¶YEÉ9MûÎK   ¶0	*ÜHÜ˜ 0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100220302185121Z230511185121Z0ÅŒ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1)0'U Microsoft Operations Puerto Rico1&0$UThales TSS ESN:60BC-E383-26351%0#UMicrosoft Time-Stamp Service0Ç"0	*ÜHÜ˜ Ç 0Ç
Ç Ÿòø{R#Á…¸‘	û<˚&ßsÂÊ“≤®{÷
É/1ÄÆó∑†v¥ˇŒ˛o¥ å‘;„Æˆ|‹k;dGÆUÛ-ΩªìÀ⁄«Ù÷üÆr¥fÓ-J(>ƒ:e	}∂3—è˜!0G‚ ˙ºZwΩ˚≥h<∏q#∫v’˚`+ê„7?tÑËÀ¡·æMä]∂˙U¶$÷UÈçDﬂvb®_P´[	mB“ù(¥Aﬁ/æ]ÊgÿÒ¬ˇ]G˘Âd˛∂ñ∂XfÆÀ>—√ËfrPy=?=t¶÷»⁄fqG¨¨Œ≤jπYãÂ!nÄ ô:Ç≥◊}≈%‰«îÇB3@`[ÑB\¨qº‹7hùß¡ïáë¡5≥˝ ≥Í≠+à‚c ø``PJn˜ˇD j”≥#+€¸“gD…¥9[∑ÙZ∑+ò†c≠æÉ§Ê|‰º6’>/X∆†£FÈQïÚpfÔ	˝]óÉ±»rÆÀø>¬ná∞^Ó,È±hz›E†ØŒÅsI˙GüÂÂ©ûˆ∏dó·zòLC÷·‡≈_B9Â–va| ıfì©◊ºwÔ*JØòIbˆŒ˘}˛⁄NO
*‘+Ùõ¢∑ó˚!U§ÖPÿ™V≠»˚m#∂v"π!3<Ωœ©—≤2#f£geËÒÚ'9≈"w¶F*Ò;0/¥•∑}ÁíIÇlI.PÔÔ £Ç60Ç20U:T!;¸∆ñ¢ΩıI/ÒÆ¸
Ú7ÿ0U#0Äüß] ^b]ÉÙÂ“eßS5Èr0_UX0V0T†R†PÜNhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l+`0^0\+0ÜPhttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0Uˇ0 0U%0
+0	*ÜHÜ˜ Ç Ä¿ÒX4È¢ÁÉ·õ¯É∆Ãkÿ÷Î&_ÄH6N…±7Ù¿>e'a˙—ôp[{´\µMÔJè∏èé≥y0Ê¢Ïû◊˛#ÂT‰Z´á‰f^U´v7ÁCÓTîZùS»˛∏A/ëÖJjUYæÕmÜGhÓ<ço€û %6ˆóé|jyd&1Øôâˆ‘R◊x¿4{Ü¥#∞`w!÷^~H˘R»ÆªÌ¿ò¢Ω&îÍ+¶J˛∂HBˇÓ9‰8‹>⁄ë« MR^o÷"XkU-á"àØrc™ˆb¢~ã% ˚„X¸≈PÀà)pª)ÖEèq√#®¸zi`âKÀ„JÑÁÜEx<Óyö´ÌAêÑ„3P8õΩê>1÷)=Iã7˜Z!¡ñá¡ål˛∞Guå™®â7ªa∏W(\Y≠ÑøÖ*;Ø·àΩ:ñ*Ä˛∆ßKÉwå(	Ì≈M"lßà9üØ.ıÄ∑7"Ùë¢±¶„tõl ÃΩÂ?ÍÇ±Üt®≥RMdUsÙ™Ã5Bäπ@¸á–>Õ◊„rÅøQâóL(Ê∑˚”å[e≠‡µ:∞B∂(`≥µL…/æ#¡ô?Ç∫GHÑÏù‡º√1ä&ÁÌÌÉø`©ªBÑàÚù9¡áÏÖ«`ﬂk!≥ú√¯äôvh§ƒ–0Á&!‚0$≥∞0Çq0ÇY†3   ≈ÁkûõIô     0	*ÜHÜ˜ 0Åà10	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100210930182225Z300930183225Z0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100Ç"0	*ÜHÜ˜ Ç 0Ç
Ç ‰·¶LÁ¥r!y¢À◊$yΩ’Ç”˝Óú“©lNu» 5WˆlJ‡‚Ωπ>`3ˇ\O«f˜ïSqZ‚~JZ˛∏6gÖF#µçœw2¿Ë`}jRÉD∑¶éFkÛ≈vıÜP‹¡D»q\Q17†
8nçÌ◊ÿ&S|9azƒ™˝riØ´¨ˆ6æ5&d⁄ò;∫{3≠Ä[~åùR˛∂Ëb%‹jœ]Ù˛éSœ÷ÏÖVMÔ›ºç§„ëè≤9,QúÈpi 6-pé1»5(Ω„¥á$√‡…è~µTè‹˙Uòmh;öFΩÌ§Æz)7¨ÀÎÉEÁFn 2’¿Ü0\O,‚b≤Õπ‚çà‰ñ¨Jªæq©[g`ﬁ¯íë=˝ œs}AöFuÕƒ_4›â÷˝• }~¸ŸûEﬂ∂r/€}_Ä∫€™~6Ï6Lˆ+n®QËø£—s¶M7tî4ÇÚ∑GÌßËô|?L€Ø^¬Û’ÿs=CN¡39LéºBh.ÍÑQF‚—ΩjZas g¢^◊(v‚3r◊ß ¬˙
◊co…6dã[†¶É!]_0tëîîÿπP˘âaÛ65ÑG€‹—˝≤‘≈kˆ\RQ]€%∫ØPzl≈rÔç˘RƒÖì¿<€7«?x´E∂ıá^⁄èûri∆Æ{∑∑>j‚.≠ £Ç›0ÇŸ0	+Ç7 0#	+Ç7*ßR˛dƒöæÇë<F5)œˇ/Ó0Uüß] ^b]ÉÙÂ“eßS5Èr0\U U0S0Q+Ç7LÉ}0A0?+3http://www.microsoft.com/pkiops/Docs/Repository.htm0U%0
+0	+Ç7
 S u b C A0UÜ0Uˇ0ˇ0U#0Ä’ˆVÀèË¢\bh—=îê[◊Œöƒ0VUO0M0K†I†GÜEhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z+N0L0J+0Ü>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0	*ÜHÜ˜ Ç ùU}¸*≠·,g1$[·ûrK¸©oÍ\∂>NGdx±ìó=13µ9◊¬q6?⁄dl|–u9mª1‰¬è˚l—°î"ÓÈfg:SM›ò∫∂xÿ6.ú©ÇV ∞æâËi‡∫	Ó{ﬂjoæ)Ànÿ?HuŸﬁmÇım#T‰xSu$Wπ›üÛé=∆Ûhﬂeˆ§V™˜ï∂(U'–$Ω@†ø∂]='‡@ñ8¨˜˘)â√º∞TÖB≥¸ûãâÁjÅ¬ÅBRuä6¬√as.,k{n?,	xÈë≤©[ﬂI£tºÏëÄ“=ÊJ>f;OªÜ˙2ŸñÙèˆëˆŒ∆t˝ˆLro´u0≈4∞zÿP˛
X›@<«TmùctH,±NG-¡qød˘$æsm é	Ω≥WITdŸs◊[DéZëkü§(‹g($∫8Kön˚!TkjEG©Ò∑Æ»Ëâ^Où“–LvµWT	±iD~|°als˛
ªÏAf=i˝À¡AI~~ìæÀ¯;‰∑ø¥Œ>•1QÑºø¡Ç¢{âçp˛Áµ–(âè6⁄∫L˘õˇ
È4¯$5g+‡∏Êåô÷·"Í'B=%îÊtt[j—û>Ì~†13}ºÀÈ{ø8pD—êÒ»´:ä:bŸpcSMçÓÇm•¡qj¥U3X≥°pfÚ°Ç“0Ç;0Å¸°Å‘§Å—0ÅŒ10	Undex >= 2 && this.tokens.matches1AtIndex(index - 2, _types.TokenType.dot)) {
      return false;
    }
    if (index >= 2 && [_types.TokenType._var, _types.TokenType._let, _types.TokenType._const].includes(this.tokens.tokens[index - 2].type)) {
      // Declarations don't need an extra assignment. This doesn't avoid the
      // assignment for comma-separated declarations, but it's still correct
      // since the assignment is just redundant.
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken),
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.copyToken();
    this.tokens.appendCode(` ${assignmentSnippet} =`);
    return true;
  }

  /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */
   processComplexAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    if (identifierToken.type !== _types.TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, _types.TokenType.dot)) {
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken),
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(` = ${assignmentSnippet}`);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `++a`, where `a` might be an exported value.
   */
   processPreIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== _types.TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    // Ignore things like ++a.b and ++a[b] and ++a().b.
    if (
      index + 2 < this.tokens.tokens.length &&
      (this.tokens.matches1AtIndex(index + 2, _types.TokenType.dot) ||
        this.tokens.matches1AtIndex(index + 2, _types.TokenType.bracketL) ||
        this.tokens.matches1AtIndex(index + 2, _types.TokenType.parenL))
    ) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(`${assignmentSnippet} = `);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
   processPostIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index];
    const operatorToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== _types.TokenType.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, _types.TokenType.dot)) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    const operatorCode = this.tokens.rawCodeForToken(operatorToken);
    // We might also replace the identifier with something like exports.x, so
    // do that replacement here as well.
    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
    if (operatorCode === "++") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
    } else if (operatorCode === "--") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);
    } else {
      throw new Error(`Unexpected operator: ${operatorCode}`);
    }
    this.tokens.removeToken();
    return true;
  }

   processExportDefault() {
    let exportedRuntimeValue = true;
    if (
      this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._function, _types.TokenType.name) ||
      // export default async function
      (this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType.name, _types.TokenType._function, _types.TokenType.name) &&
        this.tokens.matchesContextualAtIndex(
          this.tokens.currentIndex() + 2,
          _keywords.ContextualKeyword._async,
        ))
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      // Named function export case: change it to a top-level function
      // declaration followed by exports statement.
      const name = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (
      this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._class, _types.TokenType.name) ||
      this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType._abstract, _types.TokenType._class, _types.TokenType.name) ||
      this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType.at)
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.copyDecorators();
      if (this.tokens.matches1(_types.TokenType._abstract)) {
        this.tokens.removeToken();
      }
      const name = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${name};`);
      // After this point, this is a plain "export default E" statement.
    } else if (
      _shouldElideDefaultExport2.default.call(void 0, 
        this.isTypeScriptTransformEnabled,
        this.keepUnusedImports,
        this.tokens,
        this.declarationInfo,
      )
    ) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export default e`,
      // where `e` is an identifier.
      exportedRuntimeValue = false;
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
    } else if (this.reactHotLoaderTransformer) {
      // We need to assign E to a variable. Change "export default E" to
      // "let _default; exports.default = _default = E"
      const defaultVarName = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);
      this.tokens.copyToken();
      this.tokens.appendCode(` = ${defaultVarName} =`);
      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
    } else {
      // Change "export default E" to "exports.default = E"
      this.tokens.replaceToken("exports.");
      this.tokens.copyToken();
      this.tokens.appendCode(" =");
    }
    if (exportedRuntimeValue) {
      this.hadDefaultExport = true;
    }
  }

   copyDecorators() {
    while (this.tokens.matches1(_types.TokenType.at)) {
      this.tokens.copyToken();
      if (this.tokens.matches1(_types.TokenType.parenL)) {
        this.tokens.copyExpectedToken(_types.TokenType.parenL);
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(_types.TokenType.parenR);
      } else {
        this.tokens.copyExpectedToken(_types.TokenType.name);
        while (this.tokens.matches1(_types.TokenType.dot)) {
          this.tokens.copyExpectedToken(_types.TokenType.dot);
          this.tokens.copyExpectedToken(_types.TokenType.name);
        }
        if (this.tokens.matches1(_types.TokenType.parenL)) {
          this.tokens.copyExpectedToken(_types.TokenType.parenL);
          this.rootTransformer.processBalancedCode();
          this.tokens.copyExpectedToken(_types.TokenType.parenR);
        }
      }
    }
  }

  /**
   * Transform a declaration like `export var`, `export let`, or `export const`.
   */
   processExportVar() {
    if (this.isSimpleExportVar()) {
      this.processSimpleExportVar();
    } else {
      this.processComplexExportVar();
    }
  }

  /**
   * Determine if the export is of the form:
   * export var/let/const [varName] = [expr];
   * In other words, determine if function name inference might apply.
   */
   isSimpleExportVar() {
    let tokenIndex = this.tokens.currentIndex();
    // export
    tokenIndex++;
    // var/let/const
    tokenIndex++;
    if (!this.tokens.matches1AtIndex(tokenIndex, _types.TokenType.name)) {
      return false;
    }
    tokenIndex++;
    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {
      tokenIndex++;
    }
    if (!this.tokens.matches1AtIndex(tokenIndex, _types.TokenType.eq)) {
      return false;
    }
    return true;
  }

  /**
   * Transform an `export var` declaration initializing a single variable.
   *
   * For example, this:
   * export const f = () => {};
   * becomes this:
   * const f = () => {}; exports.f = f;
   *
   * The variable is unused (e.g. exports.f has the true value of the export).
   * We need to produce an assignment of this form so that the function will
   * have an inferred name of "f", which wouldn't happen in the more general
   * case below.
   */
   processSimpleExportVar() {
    // export
    this.tokens.removeInitialToken();
    // var/let/const
    this.tokens.copyToken();
    const varName = this.tokens.identifierName();
    // x: number  ->  x
    while (!this.tokens.matches1(_types.TokenType.eq)) {
      this.rootTransformer.processToken();
    }
    const endIndex = this.tokens.currentToken().rhsEndIndex;
    if (endIndex == null) {
      throw new Error("Expected = token with an end index.");
    }
    while (this.tokens.currentIndex() < endIndex) {
      this.rootTransformer.processToken();
    }
    this.tokens.appendCode(`; exports.${varName} = ${varName}`);
  }

  /**
   * Transform normal declaration exports, including handling destructuring.
   * For example, this:
   * export const {x: [a = 2, b], c} = d;
   * becomes this:
   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)
   */
   processComplexExportVar() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const needsParens = this.tokens.matches1(_types.TokenType.braceL);
    if (needsParens) {
      this.tokens.appendCode("(");
    }

    let depth = 0;
    while (true) {
      if (
        this.tokens.matches1(_types.TokenType.braceL) ||
        this.tokens.matches1(_types.TokenType.dollarBraceL) ||
        this.tokens.matches1(_types.TokenType.bracketL)
      ) {
        depth++;
        this.tokens.copyToken();
      } else if (this.tokens.matches1(_types.TokenType.braceR) || this.tokens.matches1(_types.TokenType.bracketR)) {
        depth--;
        this.tokens.copyToken();
      } else if (
        depth === 0 &&
        !this.tokens.matches1(_types.TokenType.name) &&
        !this.tokens.currentToken().isType
      ) {
        break;
      } else if (this.tokens.matches1(_types.TokenType.eq)) {
        // Default values might have assignments in the RHS that we want to ignore, so skip past
        // them.
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) {
          throw new Error("Expected = token with an end index.");
        }
        while (this.tokens.currentIndex() < endIndex) {
          this.rootTransformer.processToken();
        }
      } else {
        const token = this.tokens.currentToken();
        if (_tokenizer.isDeclaration.call(void 0, token)) {
          const name = this.tokens.identifierName();
          let replacement = this.importProcessor.getIdentifierReplacement(name);
          if (replacement === null) {
            throw new Error(`Expected a replacement for ${name} in \`export var\` syntax.`);
          }
          if (_tokenizer.isObjectShorthandDeclaration.call(void 0, token)) {
            replacement = `${name}: ${replacement}`;
          }
          this.tokens.replaceToken(replacement);
        } else {
          this.rootTransformer.processToken();
        }
      }
    }

    if (needsParens) {
      // Seek to the end of the RHS.
      const endIndex = this.tokens.currentToken().rhsEndIndex;
      if (endIndex == null) {
        throw new Error("Expected = token with an end index.");
      }
      while (this.tokens.currentIndex() < endIndex) {
        this.rootTransformer.processToken();
      }
      this.tokens.appendCode(")");
    }
  }

  /**
   * Transform this:
   * export function foo() {}
   * into this:
   * function foo() {} exports.foo = foo;
   */
   processExportFunction() {
    this.tokens.replaceToken("");
    const name = this.processNamedFunction();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }

  /**
   * Skip past a function with a name and return that name.
   */
   processNamedFunction() {
    if (this.tokens.matches1(_types.TokenType._function)) {
      this.tokens.copyToken();
    } else if (this.tokens.matches2(_types.TokenType.name, _types.TokenType._function)) {
      if (!this.tokens.matchesContextual(_keywords.ContextualKeyword._async)) {
        throw new Error("Expected async keyword in function export.");
      }
      this.tokens.copyToken();
      this.tokens.copyToken();
    }
    if (this.tokens.matches1(_types.TokenType.star)) {
      this.tokens.copyToken();
    }
    if (!this.tokens.matches1(_types.TokenType.name)) {
      throw new Error("Expected identifier for exported function name.");
    }
    const name = this.tokens.identifierName();
    this.tokens.copyToken();
    if (this.tokens.currentToken().isType) {
      this.tokens.removeInitialToken();
      while (this.tokens.currentToken().isType) {
        this.tokens.removeToken();
      }
    }
    this.tokens.copyExpectedToken(_types.TokenType.parenL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(_types.TokenType.parenR);
    this.rootTransformer.processPossibleTypeRange();
    this.tokens.copyExpectedToken(_types.TokenType.braceL);
    this.rootTransformer.processBalancedCode();
    this.tokens.copyExpectedToken(_types.TokenType.braceR);
    return name;
  }

  /**
   * Transform this:
   * export class A {}
   * into this:
   * class A {} exports.A = A;
   */
   processExportClass() {
    this.tokens.removeInitialToken();
    this.copyDecorators();
    if (this.tokens.matches1(_types.TokenType._abstract)) {
      this.tokens.removeToken();
    }
    const name = this.rootTransformer.processNamedClass();
    this.tokens.appendCode(` exports.${name} = ${name};`);
  }

  /**
   * Transform this:
   * export {a, b as c};
   * into this:
   * exports.a = a; exports.c = b;
   *
   * OR
   *
   * Transform this:
   * export {a, b as c} from './foo';
   * into the pre-generated Object.defineProperty code from the ImportProcessor.
   *
   * For the first case, if the TypeScript transform is enabled, we need to skip
   * exports that are only defined as types.
   */
   processExportBindings() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();

    const isReExport = _isExportFrom2.default.call(void 0, this.tokens);

    const exportStatements = [];
    while (true) {
      if (this.tokens.matches1(_types.TokenType.braceR)) {
        this.tokens.removeToken();
        break;
      }

      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens);

      while (this.tokens.currentIndex() < specifierInfo.endIndex) {
        this.tokens.removeToken();
      }

      const shouldRemoveExport =
        specifierInfo.isType ||
        (!isReExport && this.shouldElideExportedIdentifier(specifierInfo.leftName));
      if (!shouldRemoveExport) {
        const exportedName = specifierInfo.rightName;
        if (exportedName === "default") {
          this.hadDefaultExport = true;
        } else {
          this.hadNamedExport = true;
        }
        const localName = specifierInfo.leftName;
        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);
        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);
      }

      if (this.tokens.matches1(_types.TokenType.braceR)) {
        this.tokens.removeToken();
        break;
      }
      if (this.tokens.matches2(_types.TokenType.comma, _types.TokenType.braceR)) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        break;
      } else if (this.tokens.matches1(_types.TokenType.comma)) {
        this.tokens.removeToken();
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
      }
    }

    if (this.tokens.matchesContextual(_keywords.ContextualKeyword._from)) {
      // This is an export...from, so throw away the normal named export code
      // and use the Object.defineProperty code from ImportProcessor.
      this.tokens.removeToken();
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      _removeMaybeImportAttributes.removeMaybeImportAttributes.call(void 0, this.tokens);
    } else {
      // This is a normal named export, so use that.
      this.tokens.appendCode(exportStatements.join(" "));
    }

    if (this.tokens.matches1(_types.TokenType.semi)) {
      this.tokens.removeToken();
    }
  }

   processExportStar() {
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(_types.TokenType.string)) {
      this.tokens.removeToken();
    }
    const path = this.tokens.stringValue();
    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
    _removeMaybeImportAttributes.removeMaybeImportAttributes.call(void 0, this.tokens);
    if (this.tokens.matches1(_types.TokenType.semi)) {
      this.tokens.removeToken();
    }
  }

   shouldElideExportedIdentifier(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.declarationInfo.valueDeclarations.has(name)
    );
  }
} exports.default = CJSImportTransformer;
