"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _tokenizer = require('./parser/tokenizer');
var _keywords = require('./parser/tokenizer/keywords');
var _types = require('./parser/tokenizer/types');

var _getImportExportSpecifierInfo = require('./util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _getNonTypeIdentifiers = require('./util/getNonTypeIdentifiers');
















/**
 * Class responsible for preprocessing and bookkeeping import and export declarations within the
 * file.
 *
 * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
 * interopRequireWildcard, so we also allow that mode for compatibility.
 */
 class CJSImportProcessor {
   __init() {this.nonTypeIdentifiers = new Set()}
   __init2() {this.importInfoByPath = new Map()}
   __init3() {this.importsToReplace = new Map()}
   __init4() {this.identifierReplacements = new Map()}
   __init5() {this.exportBindingsByLocalName = new Map()}

  constructor(
     nameManager,
     tokens,
     enableLegacyTypeScriptModuleInterop,
     options,
     isTypeScriptTransformEnabled,
     keepUnusedImports,
     helperManager,
  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.keepUnusedImports = keepUnusedImports;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}

  preprocessTokens() {
    for (let i = 0; i < this.tokens.tokens.length; i++) {
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._import) &&
        !this.tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)
      ) {
        this.preprocessImportAtIndex(i);
      }
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._export) &&
        !this.tokens.matches2AtIndex(i, _types.TokenType._export, _types.TokenType.eq)
      ) {
        this.preprocessExportAtIndex(i);
      }
    }
    this.generateImportReplacements();
  }

  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, this.tokens, this.options);
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      if (
        importInfo.hasBareImport ||
        importInfo.hasStarExport ||
        importInfo.exportStarNames.length > 0 ||
        importInfo.namedExports.length > 0
      ) {
        continue;
      }
      const names = [
        ...importInfo.defaultNames,
        ...importInfo.wildcardNames,
        ...importInfo.namedImports.map(({localName}) => localName),
      ];
      if (names.every((name) => this.shouldAutomaticallyElideImportedName(name))) {
        this.importsToReplace.set(path, "");
      }
    }
  }

  shouldAutomaticallyElideImportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.nonTypeIdentifiers.has(name)
    );
  }

   generateImportReplacements() {
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      const {
        defaultNames,
        wildcardNames,
        namedImports,
        namedExports,
        exportStarNames,
        hasStarExport,
      } = importInfo;

      if (
        defaultNames.length === 0 &&
        wildcardNames.length === 0 &&
        namedImports.length === 0 &&
        namedExports.length === 0 &&
        exportStarNames.length === 0 &&
        !hasStarExport
      ) {
        // Import is never used, so don't even assign a name.
        this.importsToReplace.set(path, `require('${path}');`);
        continue;
      }

      const primaryImportName = this.getFreeIdentifierForPath(path);
      let secondaryImportName;
      if (this.enableLegacyTypeScriptModuleInterop) {
        secondaryImportName = primaryImportName;
      } else {
        secondaryImportName =
          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
      }
      let requireCode = `var ${primaryImportName} = require('${path}');`;
      if (wildcardNames.length > 0) {
        for (const wildcardName of wildcardNames) {
          const moduleExpr = this.enableLegacyTypeScriptModuleInterop
            ? primaryImportName
            : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
          requireCode += ` var ${wildcardName} = ${moduleExpr};`;
        }
      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireWildcard",
        )}(${primaryImportName});`;
      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireDefault",
        )}(${primaryImportName});`;
      }

      for (const {importedName, localName} of namedExports) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom",
        )}(${primaryImportName}, '${localName}', '${importedName}');`;
      }
      for (const exportStarName of exportStarNames) {
        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
      }
      if (hasStarExport) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createStarExport",
        )}(${primaryImportName});`;
      }

      this.importsToReplace.set(path, requireCode);

      for (const defaultName of defaultNames) {
        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
      }
      for (const {importedName, localName} of namedImports) {
        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
      }
    }
  }

  getFreeIdentifierForPath(path) {
    const components = path.split("/");
    const lastComponent = components[components.length - 1];
    const baseName = lastComponent.replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${baseName}`);
  }

   preprocessImportAtIndex(index) {
    const defaultNames = [];
    const wildcardNames = [];
    const namedImports = [];

    index++;
    if (
      (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._type) ||
        this.tokens.matches1AtIndex(index, _types.TokenType._typeof)) &&
      !this.tokens.matches1AtIndex(index + 1, _types.TokenType.comma) &&
      !this.tokens.matchesContextualAtIndex(index + 1, _keywords.ContextualKeyword._from)
    ) {
      // import type declaration, so no need to process anything.
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.parenL)) {
      // Dynamic import, so nothing to do
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.name)) {
      defaultNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
      if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      }
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.star)) {
      // * as
      index += 2;
      wildcardNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
      const result = this.getNamedImports(index + 1);
      index = result.newIndex;

      for (const namedImport of result.namedImports) {
        // Treat {default as X} as a default import to ensure usage of require interop helper
        if (namedImport.importedName === "default") {
          defaultNames.push(namedImport.localName);
        } else {
          namedImports.push(namedImport);
        }
      }
    }

    if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) {
      index++;
    }

    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    importInfo.defaultNames.push(...defaultNames);
    importInfo.wildcardNames.push(...wildcardNames);
    importInfo.namedImports.push(...namedImports);
    if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {
      importInfo.hasBareImport = true;
    }
  }

   preprocessExportAtIndex(index) {
    if (
      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._var) ||
      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._let) ||
      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._const)
    ) {
      this.preprocessVarExportAtIndex(index);
    } else if (
      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._function) ||
      this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._class)
    ) {
      const exportName = this.tokens.identifierNameAtIndex(index + 2);
      this.addExportBinding(exportName, exportName);
    } else if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.name, _types.TokenType._function)) {
      const exportName = this.tokens.identifierNameAtIndex(index + 3);
      this.addExportBinding(exportName, exportName);
    } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.braceL)) {
      this.preprocessNamedExportAtIndex(index);
    } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.star)) {
      this.preprocessExportStarAtIndex(index);
    }
  }

   preprocessVarExportAtIndex(index) {
    let depth = 0;
    // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.
    for (let i = index + 2; ; i++) {
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType.braceL) ||
        this.tokens.matches1AtIndex(i, _types.TokenType.dollarBraceL) ||
        this.tokens.matches1AtIndex(i, _types.TokenType.bracketL)
      ) {
        depth++;
      } else if (
        this.tokens.matches1AtIndex(i, _types.TokenType.braceR) ||
        this.tokens.matches1AtIndex(i, _types.TokenType.bracketR)
      ) {
        depth--;
      } else if (depth === 0 && !this.tokens.matches1AtIndex(i, _types.TokenType.name)) {
        break;
      } else if (this.tokens.matches1AtIndex(1, _types.TokenType.eq)) {
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) {
          throw new Error("Expected = token with an end index.");
        }
        i = endIndex - 1;
      } else {
        const token = this.tokens.tokens[i];
        if (_tokenizer.isDeclaration.call(void 0, token)) {
          const exportName = this.tokens.identifierNameAtIndex(i);
          this.identifierReplacements.set(exportName, `exports.${exportName}`);
        }
      }
    }
  }

  /**
   * Walk this export statement just in case it's an export...from statement.
   * If it is, combine it into the import info for that path. Otherwise, just
   * bail out; it'll be handled later.
   */
   preprocessNamedExportAtIndex(index) {
    // export {
    index += 2;
    const {newIndex, namedImports} = this.getNamedImports(index);
    index = newIndex;

    if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) {
      index++;
    } else {
      // Reinterpret "a as b" to be local/exported rather than imported/local.
      for (const {importedName: localName, localName: exportedName} of namedImports) {
        this.addExportBindi‰¢°ÜıŒLëQsëöğĞìÑôÍ 5Ùx¦Ø¾f… _ŸãÌ~%KæßS€Â8ÿiÅpxˆv¬kú~ŒPøõ~|á:I8?F{ri!k^7¬ğåù¶¾bİı&êù”¥ˆÖ2h'¡p:­î÷À¯l~7µY›Ê¾+6*½gt"}çd¸ÍÈÊ&1,?P©_·tk;$åöJqäO§¯ÁäÓûûÁ!6F%¾&4ŠÕõa…E™,±ø¬¹kÖmª¾˜³‘ë6àêr^ÿ]ŠKï+ü4llpÆñ±§çyŸŸC€¥`ñZÕ3 ‚ô†^­ıß¡°Ó/yù§†Úaæ¼]5®=çÆ_ç>KVL+D –[g¼²ˆŸy°ÌØ%ú»4«~¨‰;Îıº[+n¥Ó‡&Ë~iû	Ïƒ\b¶t6`´ åƒsÖÍwƒ"XŞXÍÓ/ñ‘„Û¦«£Qş¹-‚5N{”€“l²ñüÑéKıBªñúü8z&œ››O!÷ÆºÀ;sJ4h,
aÔğB' ÁDèöï‚ä»péŞÌÁû˜dôjPOéŸÌ$ş¹HzSíª‚‡Äj#CÏª„C:ë×>ˆ®<(ËL¦ge—Zş5YÜúU~íe;1æsfgÌ_
2ÇC*ÌZ$ÏÎ¬Úd±6ÿüŸZù­Î´N:ß[€Tüã—†0Şí/hv"jšè² 6\»ù]Å$î¹ü<±?[7Ü‡	A~¸õZ—ßÁZêOè¦Ü¯œGëuÅì²Üâç6ÿ·v‚íÁÒØ®Cş;´fA0\âS OÉ9àå
…šzç˜Ô·æŞqEnë•¨WO¨ByM%eÉÃïh]],^ú‹›â‰R:ÇhÙ¢ÔH	ôGuîÔÊµNJ4—SúÃ‚2zp,.“î²ü³€SÜÁ•V·ÅÔ®´Á0Šq°s¬y15m©rÖ{·BÿšDÕgÈf
ÃÀø±8úi•B.é~¿oVØh¾µû„‰
l1~{mì‡Pä î/)X­´ÛŸÑ¿
M°¡ffJáŒQĞÆh0eHBú¯Á(nÉªÿÖ'wÁ2ç]0ƒùÉf¥b
•sª%yN—Çw¾üTS­HR#Á `ErÍ`­ä‡HAï„›!ºÁÈw‰ı³¨Ğ ¹­ ó.Z©2lÿÊo® ùÆ/ß Š*'ÓR´Ç-”;˜ŞÒƒnVî¯ºcZ–åÒf^E×½¾bÕOòíÆëº¨á
•ßÓf#V6ï×À^øÄJ÷
B 8Ä‚*Œí£Ú–îtÛ‘3=cÒf3 ™æUÑ´ $pë ¼ˆ{Ìù¼G/0²Ø0h®¤›Ÿè¡‚ĞÎä§tşùX38Xı² <çMÓ™¤Ø¡Lc€×Û‚*Aİ-Äó} 5¡+kYCw,oµÜ× ¼äÜQAîR(úì²õ›R{’­´ÄÒ8öL­LŸ¹Ù³Ü9—»jã5f“°^®'˜¡;xiÒp®ö·sĞ;²ÃâÑ·9úñÖ’`fÜ«Á"¸Êœó,#ÆâŞ@îrÅXL	µ’\èëF}yqääÁ´ƒ(ç¼«â—‹tní
ŸºGª»ÅjZn_‚dbéÔrZ"¤f€ñmâÅ¤ÏsÑ¶h¯Fš²ßdÃRWúy£äÛâŒ¿ñ‘8’‡K,èUßÃKµÖ¼­Şˆy*R[*@®ÜìÌÁîA6é²	íM£TÄÉ‚mß2
d®…cK¨\z1éd³˜k/ËWé7j ´¦`è*èæÑn„—úÖYğ¨¬0ÚòªpÖÒ¢ó!À¥t!±¥Ë1f€ƒ{É"Ä‚¤`¹,QóÒ´^»ğê±Êµ,TÏÒôfûâïğ¨ÊLOÈÙ¶D21ùJ¹cÏè¡SDÊÜüv³2 ûõ„›!wøiFbFÖÏmã%‘&-àŸ±"Øù‡ì“I4Áêob^¼©ìïÿ<æÀG²b	B›¹Ê €Œ£7ıS;ÚºHûÆê;Ò,µt–Õ‘§f(Š³aˆIœÄ Êg F¿‹#h¾ŞïkƒJ.bAo•tçî
ém	ıïÆÿ\hZ¢cØX¹³àJ~øƒk’‰‡Àƒ›·Ê…^$3ª	8úU·ÉŞ‚,İGö`µ\#‚"¢sscjSr3&4,Ç…5¿B;¬Åù6À…uAK©EÈÀb‚âÅC‘WìË½şûäI8šqÃj3ÖŞ;£Lşû{ƒÚïs	Xäò¿¨K‡§7ó§X|2şv6Ş¢)íŠ)4:š*Ìâ“\`şáã	¦FõÀ¢ÄsJÛ[½¯Oxƒ‰LC]3ºÑYc$·ğ¨9ãßnX…ê@YC‚ü¥üé.‘ÒmÇ§–	™|ë™[± q†á6Œ€&´ĞãóG»•´ÊW ¦;ou®s3º…:Nş4[¶'õ9©pçÉ½’yİP³Æ'§ü¶éÑÛ¾ûA±òLMô†¡$ˆm£Iªkh9-š×q µx›˜ø[Nµ]'4ëÖk‰ÀçS´¢·ÛÃQ…æ±/VK7ıqQ«†#û¨U=ÂñwãK×öÇûq,dL›XÌ°ĞÄ+«=M¸?SÄëÅ²®¹"È¼Kq™Cc\&ìµ‹»SÊœğu h¼h(¿.üù¤C{¸K8Ÿ1œƒ†y®™&bµïè °óB|ÿ–§€Å¤õös88hàVn•=cÎ³`Å$éÛ"ÆÁŞ°÷{Úovd”§NFù@%ñ[q°G Ùî§bo×¸v÷Pà¼6'˜ƒ);p£eÑûéßBD{	ßk•°’j*NÅ»}²¥-Ë‚–ñ†õ]ÚTæ5>9'5€kB§efwşSÓO,,|}Aÿ…1İjİü˜ü‡=`¶Ñ‘÷¸ãóÒd§¬òVÔŒôç6şÊ*R=LkWé²ªğ#ÕÚÿ®ŒøÓÊázUÙ+'Ú8ßú¼¥l„7‚H(…›¦Ö$Â¨ªã’k ÕTA§|¾Ú‰ğ	ÌëPwjq{ñ·\nkíÂ”±+wys/4¦­T¯¥ŒmÇ³@¯È¯Ş˜º¥³µ¿F‰m€Ô‚ætÔª½ÍûÊuÉ<Öø÷†ª QÂÊ?9üÓ‡Ç­HçUæ;©)¡û±£k¶[Dv×UÅê´İ+ÑüI>ôÁˆ?Şÿî¬ÛzAôS8´â¦GCQPGRS~y—XàYQøúÆf“eÂRN³V>ç’—AG[F‚d4á‘áªÍËŠ®‚õæºÊH!‘è›Ò Ô®“ââ¢XÏ™G·şCØäo|rœj†õŠñã'yûUÓYİ«á—#PZÔyéxÏ«ğä‹YvÓp¾±&î#tfï›cB`ÓTHm‹c;ŠĞÊœ‹\Ğ¦28ÉÇ’• ş·Ë»"yŸ§²µ3m¬1]`0Ö÷õp´ô÷÷ğ-v^ÚœÁ÷¾áÒµ7øßË"‡öLªMèÔUyŒäØCÜÇæ ¦ıœ#ã‘ˆ¨ÂåkaU  £o¹8@‚™¥åÅÏpG½èş<¡üQæ‰$HëÛóÉÏ8ş;ÓZ‚g)&Å0 Z5fŒÎÀ¨Ùûà‰c¡õè½b”z·m3Aå¶“d„¯3Å—K¨ıÏü÷+ ĞQI„<Â8¡şXÑ“>Q½qÓü	§¹’Ç·J 4kŸî ‰c$0CB5´•}x<![´›h™ùw,3Tˆà5Ï~‘¹´öSg>›¨yÎ¸âJB3àBEE@;¹ áûø˜Øîû:Ü5KX²>ÚÒXjê1ê•©†óï³YÕ¼Á]j·Ì5ScEWá5x¥9…ºÒ*C%O6¥([³ºÜÛeS¹Bu±ì_èóYß“Ş†Oæ_¥Z¿)ê	š,*(	JiB QBf¿(š·gØpÃ(è³9ôoeøÁ³Ì	
ˆÒŞÑ[I: Bi‰Í7ÕJi¦5±Ï‹ƒàŞ%ÜÉI¤9IB“á4tÙÖ©™B>Uê T‘†Fş9øqò„XÓêë|vµ,šÅëÈ_i,C®ªÑAóQíŸüí¡ofø1
ÊB2E
ª(~j8OG¤úşù(çZù‹Á›^kmKôYğ4 ¥d Ú7è?¢fÃ<BJÄIÓ
­ Õe}ÓÏ•|ºÑ`r<2¾ÃÆù?xÃ
zôC=_Y†¸Æ:A¹;£.e	”´Lö>ÙíÚ´aM&DĞ- NCåç=TºH²N*³4‰*òŸJd¬¢§
Ô÷”T4Û<É/ø2¦UÁ¬Ó¯ç…u[şÀ´ÚD*¸iŠ™=E5eæƒm¶ò¬ææŒGûÔ:ßpuc1Æ(Õ®H8§ålªÔÊ ±gû#¨Jå½Ğë±3ä±A—îeåúğ%æAAÇ!]¾¿­jjvË‚lmèâø^<ÑÒ¡DLéş&A‚_N	åí†®;z™aÿq—¹tïü˜ö½!ñÙÙ)ĞØÁğÜñğlî{Ïó¿‚ÔĞê1FŸk›?Êƒ»¡ìªUº’M¡ÒÓı7q?a Gé°Í`4`ÂÙdÄ‘R!LÓ}"Ü¹ÓH~“)7aĞÌ­
§U >€ïcBÎKß5‘Ú£[óÊJ¥ÑÇÓËPTuÎÓn_ñÄ€¤¤èr|`Â£(ıÒš{Ò±ÊĞ?K*`[Sà¿€•×<‰ckÜLŒ…<óØ"Õ·øxvÎaXÅÔ	ÉGèİkôäK-iİ fW>ÓtZãsã+?[L+¨Å;?Û ‚dD"é©i@Qwí™‘/óíÕRwô½Y±Šã½‚Äù‚ñ>Ãğ~=ôÑÕ(O‰Õà_ µİY0]a™ãÔx˜¦h6Q.|Rb<ªvB	“	Nÿ[32y˜¶`_ë_4MÙ}àåâ©òf(§ÜO±ü2€ãÜƒé%;Œvrä›Ö
†à•Ó6·P?¶ğIgjÎ•!Ã~v`2ù¯[˜2>’NIñir]”ÉÇ¢:¢g;æI:ÛÜå-ª¤äQÃõšœ¨Ô§¿û@Gäöd¯áµÖ§
 FÖ
eÃùÜ,Æ¹ö…”z^gÚï^j
Ş9øÿÉ·.î§lÔ¬ùğ&>:ä Œ·ôi¸k}ª•ê;-È—Ç	 1·o}´É%ôÓmªm±õÏN&Ÿ'1Ş=+A×ÚßşEemÎğHù–Úà¨^7&”ê]‘¹“Ç‚Ÿrk