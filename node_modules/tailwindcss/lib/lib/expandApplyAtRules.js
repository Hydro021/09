 ocasiones, los sitios web que normalmente son seguros contienen malware. Este contenido malintencionado procede de $2, un conocido distribuidor de malware.Si entiendes los riesgos para tu seguridad, puedes <a href="#" id="proceed-link">acceder a este sitio no seguro</a> antes de que se hayan eliminado los programas peligrosos.Es posible que los atacantes del sitio que quieres visitar instalen software dañino que robe o elimine cosas como tus fotos, contraseña, mensajes o el número de tu tarjeta de crédito. Chrome te recomienda que vuelvas a un sitio seguro. <a href="#" id="learn-more-link">Más información</a>Chrome tiene funciones de seguridad integradas para protegerte mientras navegas (como Navegación segura de Google, la cual <a href="#" id="diagnostic-link">recientemente ha detectado malware</a> en el sitio al que intentas acceder).Chrome tiene funciones de seguridad integradas para protegerte mientras navegas, como Navegación segura de Google. Navegación segura <a href="#" id="diagnostic-link">recientemente ha detectado malware en $1</a>, que está insertado en el sitio al que intentas acceder.En ocasiones, los atacantes vulneran sitios que normalmente son seguros. Solo accede a <a href="#" id="proceed-link">este sitio no seguro</a> si tienes la certeza de entender los riesgos.Ayuda a mejorar la seguridad de todos en la Web enviando a Google las <a href="#" id="whitepaper-link">URL de algunas de las páginas que visites, información limitada del sistema y parte del contenido de las páginas</a>. <a id="privacy-link" href="#">Política de Privacidad</a>Para disfrutar del máximo nivel de seguridad en Chrome, <a href="#" id="enhanced-protection-link">activa la protección mejorada</a>.<a href="#" id="enhanced-protection-link">Activa la protección mejorada</a> para tener el máximo nivel de seguridad de ChromeEl sitio web al que vas a acceder contiene programas dañinosEs posible que los atacantes que se encuentren en <strong>$1</strong> intenten engañarte para que instales programas que empeoren tu experiencia de navegación (por ejemplo, que cambien tu página principal o muestren anuncios adicionales en los sitios a los que accedas). <a href="#" id="learn-more-link">Más información</a>La función de Navegación segura de Google <a href="#" id="diagnostic-link">encontró programas dañinos</a> recientemente en el sitio $1.Si entiendes los riesgos para tu seguridad, puedes <a href="#" id="proceed-link">acceder a este sitio</a> antes de que se hayan eliminado los programas dañinos.Es posible que los atacantes del sitio que quieres visitar te engañen para que instales software dañino que afecte a tu navegación (por ejemplo, que cambie tu página principal o te muestre anuncios adicionales en los sitios que visites). Chrome te recomienda volver a un sitio seguro para evitar daños. <a href="#" id="learn-more-link">Más información</a>Chrome tiene funciones de seguridad integradas para protegerte mientras navegas (como Navegación segura de Google, la cual recientemente<a href="#" id="diagnostic-link">ha detectado software dañino</a> en el sitio al que intentas acceder).Chrome tiene funciones de seguridad integradas para protegerte mientras navegas, como Navegación segura de Google. Hace poco, Navegación segura <a href="#" id="diagnostic-link">detectó software dañino en $1</a>, que está insertado en el sitio al que intentas acceder.El sitio web al que vas a acceder es engañosoEs posible que los atacantes que se encuentren en <strong>$1</strong> intenten engañarte para que realices una acción peligrosa, como instalar software o revelar tu información personal (por ejemplo, contraseñas, números de teléfono o tarjetas de crédito). <a href="#" id="learn-more-link">Más información</a>La función Navegación segura de Google <a href="#" id="diagnostic-link">ha detectado phishing</a> en $1. Los sitios web de phishing suplantan la identidad de otros sitios web para engañarte.Puedes <a href="#" id="report-error-link">informar de un problema de detección</a> o, si comprendes los riesgos que conlleva esta acción para tu seguridad, <a href="#" id="proceed-link">accede a este sitio web no seguro</a>.Es posible que los atacantes del sitio que quieres visitar te engañen para que instales software o proporciones información como tu contraseña o tu número de teléfono o tarjeta de crédito. Chrome te recomienda que vuelvas a un sitio seguro. <a href="#" id="learn-more-link">Más información</a>Chrome tiene funciones de seguridad integradas para protegerte mientras navegas (como Navegación segura de Google, la cual <a href="#" id="diagnostic-link">recientemente ha detectado phishing</a> en el sitio al que intentas acceder). Los sitios de phishing se hacen pasar por otros sitios para engañarte.<br/><br/>En ocasiones, los atacantes vulneran sitios que normalmente son seguros. Si crees que se ha producido un error y que este sitio no es peligroso, <a href="#" id="report-error-link">indícanoslo</a>.Chrome tiene funciones de seguridad integradas para protegerte mientras navegas, como Navegación segura de Google. Hace poco, Navegación segura <a href="#" id="diagnostic-link">detectó phishing en $1</a>, que está insertado en el sitio que intentas visitar.<br/><br/>En ocasiones, los atacantes vulneran sitios que normalmente son seguros. Si crees que se ha producido un error y que este sitio no es peligroso, <a href="#" id="report-error-link">indícanoslo</a>.Solo accede a <a href="#" id="proceed-link">este sitio no seguro</a> si tienes la certeza de entender los riesgos.Contenido peligroso bloqueado.Es posible que este contenido intente instalar software peligroso que robe o elimine tu información en el dispositivo. <a href="#" id="proceed-link">Mostrar de todos modos</a>Contenido engañoso bloqueado.Es posible que este contenido intente engañarte para que instales software o reveles información personal. <a href="#" id="proceed-link">Mostrar de todos modos</a>Contenido dañino bloqueado.Este contenido podría intentar instalar aplicaciones engañosas que se hagan pasar por otra persona o recojan datos que podrían usarse para realizar un seguimiento de tu actividad. <a href="#" id="proceed-link">Mostrar de todos modos</a>Es posible que se cobren cargos en el futuro.Estos cargos pueden ser únicos o periódicos, y es posible que no se indiquen de una forma evidente. <a href="#" id="proceed-link">Mostrar de todos modos</a>Ayuda para la conexiónSolucionar errores de conexión<p>Si intentas acceder a un sitio web y no se abre, prueba estos pasos para solucionar problemas:</p>
    <ol>
    <li>Comprueba si hay algún error ortográfico en la dirección web.</li>
    <li>Comprueba que tu conexión a Internet funcione con normalidad.</li>
    <li>Ponte en contacto con el propietario del sitio web.</li>
    </ol>Solucionar un error específico"La conexión no es privada" o "<span class="error-code">NET::ERR_CERT_AUTHORITY_INVALID</span>" o "<span class="error-code">ERR_CERT_COMMON_NAME_INVALID</span>" o "<span class="error-code">NET::ERR_CERT_WEAK_SIGNATURE_ALGORITHM</span>" o "<span class="error-code">ERR_CERT_SYMANTEC_LEGACY</span>" o "Error de certificado SSL""Conéctate a la red""Tu reloj está atrasado" o "Tu reloj está adelantado" o "<span class="error-code">NET::ERR_CERT_DATE_INVALID</span>"<h4>Paso 1: Inicia sesión en el portal</h4>
    <p>Para acceder a las redes Wi‑Fi de sitios como cafeterías o aeropuertos, tienes que iniciar sesión. Para ver la página de inicio de sesión, accede a una página que utilice <code>http://</code>.</p>
    <ol>
    <li>Accede a cualquier sitio web que empiece por <code>http://</code>, como <a href="http://example.com" target="_blank">http://example.com</a>.</li>
    <li>En la página de inicio de sesión que se abre, inicia sesión para utilizar la conexión a Internet.</li>
    </ol>
    <h4>Paso 2: Abre la página en modo Incógnito (solo en ordenadores)</h4>
    <p>Abre la página que estabas visitando en una ventana de Incógnito.</p>
    <p>Si la página se abre, significa que una extensión de Chrome no funciona correctamente. Para solucionarlo, desactiva esa ex:font-bold` with `.abc` in `.hover\:font-bold:hover` resulting in `.abc:hover`
   *
   * @param {string} selector
   * @param {string} utilitySelectors
   * @param {string} candidate
   */ function replaceSelector(selector, utilitySelectors, candidate) {
        let selectorList = extractSelectors(selector);
        let utilitySelectorsList = extractSelectors(utilitySelectors);
        let candidateList = extractSelectors(`.${(0, _escapeClassName.default)(candidate)}`);
        let candidateClass = candidateList.nodes[0].nodes[0];
        selectorList.each((sel)=>{
            /** @type {Set<import('postcss-selector-parser').Selector>} */ let replaced = new Set();
            utilitySelectorsList.each((utilitySelector)=>{
                let hasReplaced = false;
                utilitySelector = utilitySelector.clone();
                utilitySelector.walkClasses((node)=>{
                    if (node.value !== candidateClass.value) {
                        return;
                    }
                    // Don't replace multiple instances of the same class
                    // This is theoretically correct but only partially
                    // We'd need to generate every possible permutation of the replacement
                    // For example with `.foo + .foo { … }` and `section { @apply foo; }`
                    // We'd need to generate all of these:
                    // - `.foo + .foo`
                    // - `.foo + section`
                    // - `section + .foo`
                    // - `section + section`
                    if (hasReplaced) {
                        return;
                    }
                    // Since you can only `@apply` class names this is sufficient
                    // We want to replace the matched class name with the selector the user is using
                    // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`
                    node.replaceWith(...sel.nodes.map((node)=>node.clone()));
                    // Record that we did something and we want to use this new selector
                    replaced.add(utilitySelector);
                    hasReplaced = true;
                });
            });
            // Sort tag names before class names (but only sort each group (separated by a combinator)
            // separately and not in total)
            // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`
            for (let sel of replaced){
                let groups = [
                    []
                ];
                for (let node of sel.nodes){
                    if (node.type === "combinator") {
                        groups.push(node);
                        groups.push([]);
                    } else {
                        let last = groups[groups.length - 1];
                        last.push(node);
                    }
                }
                sel.nodes = [];
                for (let group of groups){
                    if (Array.isArray(group)) {
                        group.sort((a, b)=>{
                            if (a.type === "tag" && b.type === "class") {
                                return -1;
                            } else if (a.type === "class" && b.type === "tag") {
                                return 1;
                            } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
                                return -1;
                            } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
                                return 1;
                            }
                            return 0;
                        });
                    }
                    sel.nodes = sel.nodes.concat(group);
                }
            }
            sel.replaceWith(...replaced);
        });
        return selectorList.toString();
    }
    let perParentApplies = new Map();
    // Collect all apply candidates and their rules
    for (let apply of applies){
        let [candidates] = perParentApplies.get(apply.parent) || [
            [],
            apply.source
        ];
        perParentApplies.set(apply.parent, [
            candidates,
            apply.source
        ]);
        let [applyCandidates, important] = extractApplyCandidates(apply.params);
        if (apply.parent.type === "atrule") {
            if (apply.parent.name === "screen") {
                let screenType = apply.parent.params;
                throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates.map((c)=>`${screenType}:${c}`).join(" ")} instead.`);
            }
            throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);
        }
        for (let applyCandidate of applyCandidates){
            if ([
                prefix(context, "group"),
                prefix(context, "peer")
            ].includes(applyCandidate)) {
                // TODO: Link to specific documentation page with error code.
                throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);
            }
            if (!applyClassCache.has(applyCandidate)) {
                throw apply.error(`The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
            }
            let rules = applyClassCache.get(applyCandidate);
            // Verify that we can apply the class
            for (let [, rule] of rules){
                if (rule.type === "atrule") {
                    continue;
                }
                rule.walkRules(()=>{
                    throw apply.error([
                        `The \`${applyCandidate}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`,
                        "Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:",
                        "https://tailwindcss.com/docs/using-with-preprocessors#nesting"
                    ].join("\n"));
                });
            }
            candidates.push([
                applyCandidate,
                important,
                rules
            ]);
        }
    }
    for (let [parent, [candidates, atApplySource]] of perParentApplies){
        let siblings = [];
        for (let [applyCandidate, important, rules] of candidates){
            let potentialApplyCandidates = [
                applyCandidate,
                ...extractBaseCandidates([
                    applyCandidate
                ], context.tailwindConfig.separator)
            ];
            for (let [meta, node] of rules){
                let parentClasses = extractClasses(parent);
                let nodeClasses = extractClasses(node);
                // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`
                // So we've split them into groups
                nodeClasses = nodeClasses.groups.filter((classList)=>classList.some((className)=>potentialApplyCandidates.includes(className))).flat();
                // Add base utility classes from the @apply node to the list of
                // classes to check whether it intersects and therefore results in a
                // circular dependency or not.
                //
                // E.g.:
                // .foo {
                //   @apply hover:a; // This applies "a" but with a modifier
                // }
                //
                // We only have to do that with base classes of the `node`, not of the `parent`
                // E.g.:
                // .hover\:foo {
                //   @apply bar;
                // }
                // .bar {
                //   @apply foo;
                // }
                //
                // This should not result in a circular dependency because we are
                // just applying `.foo` and the rule above is `.hover\:foo` which is
                // unrelated. However, if we were to apply `hover:foo` then we _did_
                // have to include this one.
                nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));
                let intersects = parentClasses.some((selector)=>nodeClasses.includes(selector));
                if (intersects) {
                    throw node.error(`You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`);
                }
                let root = _postcss.default.root({
                    nodes: [
                        node.clone()
                    ]
                });
                // Make sure every node in the entire tree points back at the @apply rule that generated it
                root.walk((node)=>{
                    node.source = atApplySource;
                });
                let canRewriteSelector = node.type !== "atrule" || node.type === "atrule" && node.name !== "keyframes";
                if (canRewriteSelector) {
                    root.walkRules((rule)=>{
                        // Let's imagine you have the following structure:
                        //
                        // .foo {
                        //   @apply bar;
                        // }
                        //
                        // @supports (a: b) {
                        //   .bar {
                        //     color: blue
                        //   }
                        //
                        //   .something-unrelated {}
                        // }
                        //
                        // In this case we want to apply `.bar` but it happens to be in
                        // an atrule node. We clone that node instead of the nested one
                        // because we still want that @supports rule to be there once we
                        // applied everything.
                        //
                        // However it happens to be that the `.something-unrelated` is
                        // also in that same shared @supports atrule. This is not good,
                        // and this should not be there. The good part is that this is
                        // a clone already and it can be safely removed. The question is
                        // how do we know we can remove it. Basically what we can do is
                        // match it against the applyCandidate that you want to apply. If
                        // it doesn't match the we can safely delete it.
                        //
                        // If we didn't do this, then the `replaceSelector` function
                        // would have replaced this with something that didn't exist and
                        // therefore it removed the selector altogether. In this specific
                        // case it would result in `{}` instead of `.something-unrelated {}`
                        if (!extractClasses(rule).some((candidate)=>candidate === applyCandidate)) {
                            rule.remove();
                            return;
                        }
                        // Strip the important selector from the parent selector if at the beginning
                        let importantSelector = typeof context.tailwindConfig.important === "string" ? context.tailwindConfig.important : null;
                        // We only want to move the "important" selector if this is a Tailwind-generated utility
                        // We do *not* want to do this for user CSS that happens to be structured the same
                        let isGenerated = parent.raws.tailwind !== undefined;
                        let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;
                        // If the selector becomes empty after replacing the important selector
                        // This means that it's the same as the parent selector and we don't want to replace it
                        // Otherwise we'll crash
                        if (parentSelector === "") {
                            parentSelector = parent.selector;
                        }
                        rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate);
                        // And then re-add it if it was removed
                        if (importantSelector && parentSelector !== parent.selector) {
                            rule.selector = (0, _applyImportantSelector.applyImportantSelector)(rule.selector, importantSelector);
                        }
                        rule.walkDecls((d)=>{
                            d.important = meta.important || important;
                        });
                        // Move pseudo elements to the end of the selector (if necessary)
                        let selector = (0, _postcssselectorparser.default)().astSync(rule.selector);
                        selector.each((sel)=>(0, _pseudoElements.movePseudos)(sel));
                        rule.selector = selector.toString();
                    });
                }
                // It could be that the node we were inserted was removed because the class didn't match
                // If that was the *only* rule in the parent, then we have nothing add so we skip it
                if (!root.nodes[0]) {
                    continue;
                }
                // Insert it
                siblings.push([
                    meta.sort,
                    root.nodes[0]
                ]);
            }
        }
        // Inject the rules, sorted, correctly
        let nodes = context.offsets.sort(siblings).map((s)=>s[1]);
        // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }
        parent.after(nodes);
    }
    for (let apply of applies){
        // If there are left-over declarations, just remove the @apply
        if (apply.parent.nodes.length > 1) {
            apply.remove();
        } else {
            // The node is empty, drop the full node
            apply.parent.remove();
        }
    }
    // Do it again, in case we have other `@apply` rules
    processApply(root, context, localCache);
}
function expandApplyAtRules(context) {
    return (root)=>{
        // Build a cache of the user's CSS so we can use it to resolve classes used by @apply
        let localCache = lazyCache(()=>buildLocalApplyCache(root, context));
        processApply(root, context, localCache);
    };
}
