// @ts-check
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Offsets", {
    enumerable: true,
    get: function() {
        return Offsets;
    }
});
const _bigSign = /*#__PURE__*/ _interop_require_default(require("../util/bigSign"));
const _remapbitfield = require("./remap-bitfield.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class Offsets {
    constructor(){
        /**
     * Offsets for the next rule in a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.offsets = {
            defaults: 0n,
            base: 0n,
            components: 0n,
            utilities: 0n,
            variants: 0n,
            user: 0n
        };
        /**
     * Positions for a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.layerPositions = {
            defaults: 0n,
            base: 1n,
            components: 2n,
            utilities: 3n,
            // There isn't technically a "user" layer, but we need to give it a position
            // Because it's used for ordering user-css from @apply
            user: 4n,
            variants: 5n
        };
        /**
     * The total number of functions currently registered across all variants (including arbitrary variants)
     *
     * @type {bigint}
     */ this.reservedVariantBits = 0n;
        /**
     * Positions for a given variant
     *
     * @type {Map<string, bigint>}
     */ this.variantOffsets = new Map();
    }
    /**
   * @param {Layer} layer
   * @returns {RuleOffset}
   */ create(layer) {
        return {
            layer,
            parentLayer: layer,
            arbitrary: 0n,
            variants: 0n,
            parallelIndex: 0n,
            index: this.offsets[layer]++,
            propertyOffset: 0n,
            property: "",
            options: []
        };
    }
    /**
   * @param {string} name
   * @returns {RuleOffset}
   */ arbitraryProperty(name) {
        return {
            ...this.create("utilities"),
            arbitrary: 1n,
            property: name
        };
    }
    /**
   * Get the offset for a variant
   *
   * @param {string} variant
   * @param {number} index
   * @returns {RuleOffset}
   */ forVariant(variant, index = 0) {
        let offset = this.variantOffsets.get(variant);
        if (offset === undefined) {
            throw new Error(`Cannot find offset for unknown variant ${variant}`);
        }
        return {
            ...this.create("variants"),
            variants: offset << BigInt(index)
        };
    }
    /**
   * @param {RuleOffset} rule
   * @param {RuleOffset} variant
   * @param {VariantOption} options
   * @returns {RuleOffset}
   */ applyVariantOffset(rule, variant, options) {
        options.variant = variant.variants;
        return {
            ...rule,
            layer: "variants",
            parentLayer: rule.layer === "variants" ? rule.parentLayer : rule.layer,
            variants: rule.variants | variant.variants,
            options: options.sort ? [].concat(options, rule.options) : rule.options,
            // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
            // We'll take the max of all the parallel indexes for now.
            // @ts-ignore
            parallelIndex: max([
                rule.parallelIndex,
                variant.parallelIndex
            ])
        };
    }
    /**
   * @param {RuleOffset} offset
   * @param {number} parallelIndex
   * @returns {RuleOffset}
   */ applyParallelOffset(offset, parallelIndex) {
        return {
            ...offset,
            parallelIndex: BigInt(parallelIndex)
        };
    }
    /**
   * Each variant gets 1 bit per function / rule registered.
   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
   * Additionally, every unique group of variants is grouped together in the stylesheet.
   *
   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
   *
   * @param {string[]} variants
   * @param {(name: string) => number} getLength
   */ recordVariants(variants, getLength) {
        for (let variant of variants){
            this.recordVariant(variant, getLength(variant));
        }
    }
    /**
   * The same as `recordVariants` but for a single arbitrary variant at runtime.
   * @param {string} variant
   * @param {number} fnCount
   *
   * @returns {RuleOffset} The highest offset for this variant
   */ recordVariant(variant, fnCount = 1) {
        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
        // Ensure space is reserved for each "function" in the parallel variant
        // by offsetting the next variant by the number of parallel variants
        // in the one we just added.
        // Single functions that return parallel variants are NOT handled separately here
        // They're offset by 1 (or the number of functions) as usual
        // And each rule returned is tracked separately since the functions are evaluated lazily.
        // @see `RuleOffset.parallelIndex`
        this.reservedVariantBits += BigInt(fnCount);
        return {
            ...this.create("variants"),
            variants: this.variantOffsets.get(variant)
        };
    }
    /**
   * @param {RuleOffset} a
   * @param {RuleOffset} b
   * @returns {bigint}
   */ compare(a, b) {
        // Sort layers together
        if (a.layer !== b.layer) {
            return this.layerPositions[a.layer] - this.layerPositions[b.layer];
        }
        // When sorting the `variants` layer, we need to sort based on the parent layer as well within
        // this variants layer.
        if (a.parentLayer !== b.parentLayer) {
            return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];
        }
        // Sort based on the sorting function
        for (let aOptions of a.options){
            for (let bOptions of b.options){
                if (aOptions.id !== bOptions.id) continue;
                if (!aOptions.sort || !bOptions.sort) continue;
                var _max;
                let maxFnVariant = (_max = max([
                    aOptions.variant,
                    bOptions.variant
                ])) !== null && _max !== void 0 ? _max : 0n;
                // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit
                let mask = ~(maxFnVariant | maxFnVariant - 1n);
                let aVariantsAfterFn = a.variants & mask;
                let bVariantsAfterFn = b.variants & mask;
                // If the variants the same, we _can_ sort them
                if (aVariantsAfterFn !== bVariantsAfterFn) {
                    continue;
                }
                let result = aOptions.sort({
                    value: aOptions.value,
                    modifier: aOptions.modifier
                }, {
                    value: bOptions.value,
                    modifier: bOptions.modifier
                });
                if (result !== 0) return result;
            }
        }
        // Sort variants in the order they were registered
        if (a.variants !== b.variants) {
            return a.variants - b.variants;
        }
        // Make sure each rule returned by a parallel variant is sorted in ascending order
        if (a.parallelIndex !== b.parallelIndex) {
            return a.parallelIndex - b.parallelIndex;
        }
        // Always sort arbitrary properties after other utilities
        if (a.arbitrary !== b.arbitrary) {
            return a.arbitrary - b.arbitrary;
        }
        // Always sort arbitrary properties alphabetically
        if (a.propertyOffset !== b.propertyOffset) {
            return a.propertyOffset - b.propertyOffset;
        }
        // Sort utilities, components, etc… in the order they were registered
        return a.index - b.index;
    }
    /**
   * Arbitrary variants are recorded in the order they're encountered.
   * This means that the order is not stable bet webhely USB-eszközt használA webhely MIDI-eszközt használA webhely MIDI-eszközöket használhatAz oldal nem válaszolÚj háttéralkalmazás hozzáadvaA(z) $1  el fog indulni a rendszer indításakor, és akkor is tovább fut a háttérben, ha már bezárta az összes többi $2-ablakot.A(z) $1 összeomlott. Az alkalmazás újraindításához kattintson erre a buborékra.A(z) $1 összeomlott. A bővítmény ismételt betöltéséhez kattintson erre a buborékra.Nincs háttérben futó alkalmazásEngedély kérelmezve, a válaszhoz nyomja le az F6 billentyűtAz engedélykérés lejártA(z) $1 a következőket szeretné tenni:A(z) $1 a következőre kér engedélyt: $2A(z) $1 a következőkre kér engedélyt: $2 és $3A(z) $1 a következőkre kér engedélyt: $2, $3 stb.Ez a fájlValójában ide szeretett volna menni: $1?helyi vagy megosztott fájlideiglenes adatokÖsszeomlott.Keresés az előzmények közöttChrome-előzményekNincs más eszközről származó lapMás eszközök lapjaiSzinkronizálás bekapcsolásaFolytatás másik eszközrőlHa a többi eszközén lévő lapjait is szeretné elérni, kapcsolja be a szinkronizálást&SzerkesztésMegerősítésKeresés törölveKeresési találatok a következőre: $11 találat a következőre: $1$1 találat a következőre: $21 találat$1 találatNincs találatEz a párbeszédpanel jelenleg nincs fókuszban. Nyomja le az Alt + Shift + A billentyűparancsot, ha erre a párbeszédpanelre szeretne fókuszálni.Nyomja meg a következő gombot, ha erre a buborékra szeretne fókuszálni: |$1|.Nyomja le a következő gombot, ha erre a buborékra szeretne fókuszálni, majd nyomja meg újra, hogy arra az elemre fókuszáljon, amelyre mutat: |$1|.Megjelenik majd egy sor útmutató-buborék az utasításokkal.
          Nyomja meg a következő gombot, ha valamelyik buborékra szeretne fókuszálni, majd nyomja meg újra, hogy arra az elemre fókuszáljon, amelyre mutat: |$1|.&VizsgálatSzeretne képleírásokat kapni a Google-tól?Igen, folytatomAz Élő feliratozás &bekapcsolásaAz Élő feliratozás &kikapcsolásaŰrlap kitöltése&Előző&KövetkezőMentés &másként…&Nyomtatás…&Oldal forrásának megtekintéseLink megnyitása…Konfigurálás…&Háttéroldal vizsgálataMegnyitás olvasási módbanÚj&ratöltésBöngésző újraindításának szimulálásaAlkalmazás új&ratöltéseF&ordítás $1 nyelvreKilépés a teljes képernyős módból&Keret újratöltése&Keret forrásának megtekintéseLink megnyitása új &laponLink megnyitása új &ablakbanLink megnyitása inko&gnitóablakbanLink megnyitása mintLink megnyitása mint $1Link megnyitása a következőben: $1Link megnyitása új $1 window-ablakbanLink megnyitása új lapon itt: $1Link mentése &másként…Link címén&ek másolása&E-mail cím másolásaLink szövegének má&solásaKiemelt szöveghez vezető link másolásaMegjegyzés hozzáadásaKiemelés eltávolításaKé&p mentése másként…Képcím más&olásaKé&p másolásaKép &megnyitása új laponKép betöltése&IsmétlésAz összes &vezérlő megjelenítéseForgatás &jobbraForgatás &balraVi&deo mentése másként…Vide&ocím másolásaVideókeret másolása&Videó megnyitása új laponHa&ng mentése másként…Audi&ocím másolása&Hang megnyitása új laponKép a képben&Visszavonás&ÚjraKi&vágás&BeillesztésBeillesztés egyszerű szövegként&Hozzáadás a szótárhozMindigCsak egyszerA vizuális elrendezés szemantikájának felismeréseTovábbfejlesztett helyesírás-ellenőrzés használataA továbbfejlesztett helyesírás-ellenőrzés bekapcsolásaJavaslatok betöltéseNincs több javaslat a Google-tól&Kijelölés fordítása $1 nyelvre&Keresés a(z) $1 keresőmotorral a következőre: $2&Keresés a(z) $1 rendszeren a(z) „$2” kifejezésre új laponKépkeresés a következővel: $1Keresés a képen belül a következővel: $1A képen lévő szöveg fordítása a következővel: $1Keresés az oldalon a következővel: $1Képkeresés: $1&Ugrás: $1Jelszó ajánlása…Segítsen az Automatikus kitöltés fejlesztésébenA plug-in futtatásaPlug-in elrejtése&Nyelvi beállítások&Helyesírás-ellenőrzés&Minden kiválasztott nyelv&Alap helyesírás-ellenőrzés használata&Címek és egyebekJelszavak és automatikus kitöltésÚj &lapÚj inkognitó lap&Megjelenítés lapként&Új ablakÚj &inkognitó ablakBejelentkezve mint $1&Szinkronizálás bekapcsolva&Szinkronizálás bekapcsolása…